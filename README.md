# SpringBoot Part2 Weekly Mission

## 요구사항

**(기본)** **바우처 관리 애플리케이션**

- [x] 바우처 관리 애플리케이션에 단위테스트를 작성해보세요.

  - 가능한 많은 단위 테스트코드를 작성하려고 노력해보세요.

  - 엣지 케이스(예외 케이스)를 고려해서 작성해주세요.

  - Hamcrest 의 메쳐들을 다양하게 작성해보고 익숙해져 보세요.

- [x] 바우처 관리 애플리케이션에서도 과정에서 다루었던 고객을 적용해보세요.

  - customers 테이블 정의 및 추가

  - CustomerRepository 추가 및 JdbcTemplate을 사용해서 구현

- [x] (1주차를 파일로 관리하게 했다.) 바우처 정보를 DB로 관리해보세요.

  - 바우처에 엔터티에 해당하는 vouchers 테이블을 한번 정의해보세요.

  - 바우처 레포지토리를 만들어보세요. (JdbcTemplate을 사용해서 구현)

  - 기존의 파일에서 바우처를 관리한 것을 vouchers 테이블을 통해서 CRUD가 되게 해보세요.

- [ ] **(심화)** **바우처 지갑을 만들어보세요.**
  - 특정 고객에게 바우처를 할당할 수 있습니다.
  - 고객이 어떤 바우처를 보유하고 있는지 조회할 수 있어야 합니다.
  - 고객이 보유한 바우처를 제거할 수 있어야 합니다.
  - 특정 바우처를 보유한 고객을 조회할 수 있어야 합니다.
- 현재 구현 상황
  - 현재 FK 등록으로 특정 고객이 특정 바우처를 소유할 수 있게끔 해놨습니다.
  - 하지만 아직 고객 -> 바우처 방향의 조회를 완성하지 못했고,
  - 관련 비즈니스 로직이 미비합니다. 추가로 보충하겠습니다.



## PR 포인트

- 멘토님 피드백 포인트들을 반영하려고 애썼지만, 아직도 개선이 부족한 부분이 있다면 알려주시면 감사하겠습니다.
- H2 DB를 사용하고 있으며, 실행, 테스트 환경 모두 In-Memory DB 설정 되어있습니다.
- 의문점이 들었던 부분, 설명이 필요할 부분을 PR포인트로 정리해 두었습니다: 각 PR은 `//TODO: PR 포인트1`과 같은 형태로 정리해 두었기 때문에 InteliJ의 TODO 기능을 사용하여 인덱싱이 가능합니다.



### PR 포인트1: AfterEach, BeforeEach 순서

- 몇몇 테스트에서 AfterEach를 BeforeAll 보다 앞에 위치시켰는데, 다음과 같은 의도입니다:
  - 이 경우 AfterEach가 수행하는 작업은: Mock 객체들이 각 테스트가 끝날 때마다 초기화되게 하는 것입니다.
    세부적인 테스트 내용과 상관이 없는 편이라 더 위로 올렸습니다만,
  - 일반적으로는 BeforeAll이 더 위로 가는 게 맞다고 생각하는데(테스트 클래스 전체를 포괄하기에),
    위와 같이 해당 메서드의 역할에 따라 조정하는 것이 괜찮을까요? 아니면 적용 범위를 따져서 static한 세팅 메서드들을 위로 올리는 것이 더 나을까요?



### PR포인트2: `request` = null

- 요청 응답이 마무리되는 시점에, `request`는 생명주기가 끝난 것이기에, 일부러 GC의 대상이 되게끔 `null`을 할당해 주었습니다. SonarLint에서는 부적합하다고 보던데, 이런 식으로 명시적으로 객체를 정리하는 것은 부적합한 것일까요?



### PR포인트3: 제네릭 사용

- 아직 제네릭 사용이 익숙하지 않은데, 계속 공부 중이긴 하지만, 이런 방식으로 제네릭을 사용한 게 괜찮은 것인지 확신이 안 섭니다.



### PR포인트4: 단일 데이터를 insert할 때의 예외 처리

- 만일 1건 데이터를 insert하는 쿼리 실행에서 결과적으로 영향 받은 row의 수가 1이 아니라면 예외를 던져야 할 지, 어떤 예외가 나을지 고민했습니다.
  - 저 같은 경우 스프링 dao 관련 규정된 Exception 중에서 IncorrectResultSizeDataAccessException을 사용헀는데, 이 예외가 적합한지 확신이 서지 않아 질문 드립니다.



### PR포인트5: 단일 데이터 조회시에 queryForObject 사용

- queryForObject 사용했을 때 탐색 결과가 나오지 않는 경우 (탐색결과!=1인 경우) 예외가 발생합니다.
  - 하지만 탐색 기능의 특성상 0개가 나왔을 경우는 정상 흐름으로 볼 수 있을 것 같아서 탐색 결과가 1이 아닌 경우 무조건 예외를 터트리는 queryForObject를 사용하지 않고, query를 사용하였습니다.
  - 때문에 query로 메서드를 변경하고, 검색 결과의 size가 2 이상일 경우 예외를 던지는 식으로 처리하였습니다.
  - 이후, id값으로 조회했는데, 조회 결과가 나오지 않는다면 정상 흐름이 아니라는 이야기를 들어서, 이 경우는 queryForObject를 사용하는 것이 낫다는 의견을 들었었는데, 일리 있어서 고민이 됩니다.
  - 제 생각에는 비즈니스 로직에 맞춰서 두 방식중 어떤 것을 선택할 지를 고르는 것이 맞지 않을까 생각하고 있습니다.
  - 멘토님의 의견이 궁금합니다.



### PR포인트6: 테스트를 위한 도메인 객체?

- 테스트에서 Voucher 구현체에 대한 의존성도 줄여야 할 지 고민이 되었습니다.
- 하지만 가장 핵심이 되는 도메인이 분리된 상태로 테스트용 바우처를 만들어 사용한다면, 오히려 실제 문제 상황을 못 잡아내지 않을까 생각했습니다.
- 추가적으로, VoucherType을 enum으로 관리하고 있는데, 이로 인해 테스트용 바우처를 만들려면
  - 기존 VoucherType을 사용한다 -> 테스트용 객체를 만드는 의미가 없다
  - VoucherType을 null인 상태로 저장한다 -> 하지만 DB의 not null 제약조건을 깨야 한다.
  - 테스트용 VoucherType을 추가한다. 하지만
    - 테스트용 코드를 test 디렉토리가 아닌 실 서비스용 디렉토리에 추가하는 것은 부적합하다.
    - 더구나, enum이라 extends하여 테스트 전용 무언가를 만들 수도 없다(mocking 못하는 것과 같은 이유)
- 이런 이유로 인해 굳이 도메인 객체까지 mock을 이용해서 테스트해야 할까라는 의무이 들었습니다.

------

#### 항상 바쁘신 와중에도 꼼꼼하게 리뷰해주셔서 감사합니다.